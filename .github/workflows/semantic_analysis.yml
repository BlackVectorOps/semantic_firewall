name: Semantic Analysis

# 1. The Trigger ("on") is required at the root
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  analysis:
    name: Run Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      # Install the tool 
      - name: Install SFW
        run: go install github.com/BlackVectorOps/semantic_firewall/v2/cmd/sfw@v2.2.1

      # Make BLOCKER mode reachable for PRs and check mode for pushes
      - name: Determine Mode
        id: mode
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
             echo "mode=BLOCKER" >> $GITHUB_OUTPUT
          else
             echo "mode=check" >> $GITHUB_OUTPUT
          fi

      # Run semantic analysis
      - name: Run Semantic Analysis
        shell: bash
        run: |
          MODE="${{ steps.mode.outputs.mode }}"
          
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            BASE_SHA="${{ github.event.before }}"
            if [[ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
                BASE_SHA="HEAD^" 
            fi
          fi
          
          echo "## Semantic Analysis Report ($MODE)" >> $GITHUB_STEP_SUMMARY
          echo "Comparing HEAD vs $BASE_SHA" >> $GITHUB_STEP_SUMMARY
          echo "| File | Status | Match % |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY

          FAILED_REFACTOR=false
          TEMP_DIR=".sfw_temp_$$"
          mkdir -p "$TEMP_DIR"
          
          cp go.mod go.sum "$TEMP_DIR/" 2>/dev/null || true

          # FIX: Robust Diff Handling for Renames
          # Original used --name-only which broke on renames (treating them as del+add)
          # We use --name-status -z to parse strict file moves.
          
          # Check if there are any go files changed first to avoid empty loop errors
          if git diff --name-only "$BASE_SHA" HEAD | grep -q '\.go$'; then
            
            # Using process substitution to safely read null-terminated stream
            while IFS= read -r -d '' status; do
              case "$status" in
                R*)
                   # Rename: reads OLD_PATH then NEW_PATH
                   IFS= read -r -d '' old_path
                   IFS= read -r -d '' new_path
                   OLD_FILE_REF="$old_path"
                   NEW_FILE_REF="$new_path"
                   ;;
                *)
                   # Modified/Added/Deleted: reads PATH
                   IFS= read -r -d '' path
                   OLD_FILE_REF="$path"
                   NEW_FILE_REF="$path"
                   ;;
              esac

              # Filter: Only analyze Go files
              if [[ "$NEW_FILE_REF" != *.go ]] && [[ "$OLD_FILE_REF" != *.go ]]; then continue; fi

              # Determine filesystem paths
              if [ -f "$NEW_FILE_REF" ]; then
                  NEW_FILE="$NEW_FILE_REF"
              else
                  NEW_FILE="/dev/null"
              fi

              # Extract old file content from git
              DIR_PATH=$(dirname "$OLD_FILE_REF")
              mkdir -p "$TEMP_DIR/$DIR_PATH"
              TEMP_OLD="$TEMP_DIR/$OLD_FILE_REF"
              
              if git show "$BASE_SHA:$OLD_FILE_REF" > "$TEMP_OLD" 2>/dev/null; then
                  OLD_FILE="$TEMP_OLD"
              else
                  OLD_FILE="/dev/null"
              fi

              if [[ "$NEW_FILE" == "/dev/null" ]] && [[ "$OLD_FILE" == "/dev/null" ]]; then continue; fi
              
              if ! OUTPUT=$(sfw diff "$OLD_FILE" "$NEW_FILE"); then
                  echo "::error::sfw failed on $NEW_FILE_REF"
                  continue
              fi
              
              rm -f "$TEMP_OLD"

              if ! echo "$OUTPUT" | jq -e . >/dev/null 2>&1; then
                  echo "::error::Invalid JSON output for $NEW_FILE_REF"; continue
              fi

              PCT=$(echo "$OUTPUT" | jq -r '.summary.semantic_match_pct // 0')
              MODIFIED=$(echo "$OUTPUT" | jq -r '.summary.modified // 0')
              
              if (( $(echo "$PCT < 100" | bc -l) )); then
                  STATUS_ICON=" Modified ($MODIFIED)"
                  
                  # This block is now reachable thanks to the 'Determine Mode' fix
                  if [ "$MODE" == "BLOCKER" ]; then
                      echo "true" > /tmp/failed_refactor
                      echo "::error file=$NEW_FILE_REF::Logic change detected in safe refactor! ($PCT%)"
                  fi
              else
                  STATUS_ICON=" Preserved"
              fi
              
              echo "| \`$NEW_FILE_REF\` | $STATUS_ICON | **$PCT%** |" >> $GITHUB_STEP_SUMMARY

            done < <(git diff -z --name-status "$BASE_SHA" HEAD)
            
          else
              echo "No Go files changed." >> $GITHUB_STEP_SUMMARY
          fi

          rm -rf "$TEMP_DIR"

          if [ -f /tmp/failed_refactor ] && [ "$(cat /tmp/failed_refactor)" = "true" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo " **CI FAILED**: Logic changed in 'semantic-safe' PR." >> $GITHUB_STEP_SUMMARY
              exit 1
          fi
          exit 0