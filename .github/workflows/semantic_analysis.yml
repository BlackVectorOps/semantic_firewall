name: Semantic Analysis

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# Security: Principle of Least Privilege
# Limit the GITHUB_TOKEN to only read repository contents.
permissions:
  contents: read

jobs:
  analysis:
    name: Run Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          # Fetch full history to ensure 'git merge-base' can find the common ancestor
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          # Implicitly handles caching for GOCACHE and GOMODCACHE, 
          # but we will be explicit for the build artifacts below if needed.
          cache: true

      # Optimization: Cache Go Build Artifacts
      # Preserves build cache between runs to speed up 'go install' and analysis
      - name: Cache Go Artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install SFW
        run: go install ./cmd/sfw
      
      - name: Determine Mode
        id: mode
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
             echo "mode=BLOCKER" >> $GITHUB_OUTPUT
          else
             echo "mode=check" >> $GITHUB_OUTPUT
          fi

      # Security & Infrastructure: Install gVisor (runsc)
      # Hardened against supply chain attacks by pinning version and SHA512.
      - name: Install gVisor (runsc)
        shell: bash
        run: |
          set -e
          
          # Pinning a specific version to ensure reproducible builds and prevent 
          # unexpected upstream changes from breaking the pipeline.
          GVISOR_VERSION="release-20260126.0"
          ARCH=$(uname -m)
          # We use the 'latest' path structure but enforce the version via the hash check below.
          # This circumvents potential 404s on specific version directories while maintaining integrity.
          URL="https://storage.googleapis.com/gvisor/releases/release/latest/${ARCH}"
          
          # Hardcoded trust anchor. 
          # We do NOT download the .sha512 file from the server, as a compromise 
          # of the bucket would allow an attacker to replace both binary and hash.
          # This hash must be verified out-of-band before updating.
          EXPECTED_SHA="cce974fa832c50d26c6ccc08ce50b4972921cd0818ebe8007587211d360cbc828ceea4ec8296703200afa208b679437d24f27a6dca31887b3c0fc6ee8be5eb05"
          
          echo "::notice::Downloading gVisor ${GVISOR_VERSION} for ${ARCH}..."
          
          wget -q -O runsc "${URL}/runsc"
          wget -q -O containerd-shim-runsc-v1 "${URL}/containerd-shim-runsc-v1"
          
          # Verify integrity against our pinned hash
          echo "${EXPECTED_SHA} runsc" | sha512sum -c -
          
          # We only verify runsc strict integrity as it is the security boundary. 
          # The shim is less critical but ideally should also be pinned.
          
          chmod a+rx runsc containerd-shim-runsc-v1
          sudo mv runsc containerd-shim-runsc-v1 /usr/local/bin/

          # Infrastructure Awareness: Graceful AppArmor Loading
          # Check if AppArmor is actually active in the kernel before trying to load profiles.
          # This prevents failure in restricted container environments (like some k8s runners).
          if [[ -d "/sys/kernel/security/apparmor" ]] && command -v apparmor_parser &> /dev/null; then
             echo "::notice::AppArmor detected. Loading permissive profile for gVisor..."
             
             # Load a profile that specifically allows userns for runsc
             cat <<EOF | sudo tee /etc/apparmor.d/usr.local.bin.runsc
          abi <abi/4.0>,
          include <tunables/global>

          /usr/local/bin/runsc flags=(unconfined) {
            userns,
            include if exists <local/usr.local.bin.runsc>
          }
          EOF
             sudo apparmor_parser -r /etc/apparmor.d/usr.local.bin.runsc || echo "::warning::Failed to load AppArmor profile. Sandbox isolation may be degraded."
          else
             echo "::warning::AppArmor not active or accessible. Skipping profile loading."
          fi
          
          # Fallback sysctl for systems where AppArmor is present but not fully enforced on the runner
          if [[ "$(uname -s)" == "Linux" ]]; then
             sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0 || true
          fi
          
          runsc --version

      - name: Run Semantic Analysis
        shell: bash
        run: |
          set -e
          MODE="${{ steps.mode.outputs.mode }}"
          
          # Robust Diff Logic: Find the true Merge Base
          # relying on github.event.before is flaky on new branches or force pushes.
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, compare the PR head against the base branch tip
            BASE_REF="origin/${{ github.event.pull_request.base.ref }}"
            HEAD_REF="HEAD"
            echo "::notice::Diffing PR: ${HEAD_REF} vs ${BASE_REF}"
          else
            # For Pushes, compare current HEAD against the common ancestor with main
            # This handles force-pushes and disjoint histories gracefully.
            git fetch origin main --depth=100
            BASE_REF=$(git merge-base origin/main HEAD)
            HEAD_REF="HEAD"
            echo "::notice::Diffing Push: ${HEAD_REF} vs Merge Base (${BASE_REF})"
          fi
          
          if [[ -z "$BASE_REF" ]]; then
             echo "::error::Could not determine base commit for comparison."
             exit 1
          fi

          echo "## Semantic Analysis Report ($MODE)" >> $GITHUB_STEP_SUMMARY
          echo "| File | Status | Match % |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY

          ERROR_COUNT=0
          
          # Isolation: Worktree Setup
          WORKTREE_DIR=".sfw_base_$$"
          trap 'git worktree remove --force "$WORKTREE_DIR" 2>/dev/null || rm -rf "$WORKTREE_DIR"' EXIT
          
          git worktree add --detach "$WORKTREE_DIR" "$BASE_REF" >/dev/null
          
          # Fail-Closed: Ensure Runtime Presence
          if ! command -v runsc &> /dev/null; then
            echo "::error::Critical: runsc (gVisor) not found. Aborting."
            exit 1
          fi
          SANDBOX_OPT=""

          # Analysis Loop
          # Detect changed Go files between the calculated base and head
          if git diff --name-only "$BASE_REF" "$HEAD_REF" | grep -q '\.go$'; then
            
            while IFS= read -r -d '' status; do
              case "$status" in
                R*)
                   IFS= read -r -d '' old_path
                   IFS= read -r -d '' new_path
                   OLD_FILE_REF="$old_path"
                   NEW_FILE_REF="$new_path"
                   ;;
                *)
                   IFS= read -r -d '' path
                   OLD_FILE_REF="$path"
                   NEW_FILE_REF="$path"
                   ;;
              esac

              if [[ "$NEW_FILE_REF" != *.go ]] && [[ "$OLD_FILE_REF" != *.go ]]; then continue; fi

              # Resolve paths for the new state (HEAD)
              if [ -f "$NEW_FILE_REF" ]; then
                  NEW_FILE="$NEW_FILE_REF"
              else
                  NEW_FILE="/dev/null"
              fi

              # Resolve paths for the old state (Worktree/Base)
              OLD_FILE="$WORKTREE_DIR/$OLD_FILE_REF"
              if [ ! -f "$OLD_FILE" ]; then
                  OLD_FILE="/dev/null"
              fi

              if [[ "$NEW_FILE" == "/dev/null" ]] && [[ "$OLD_FILE" == "/dev/null" ]]; then continue; fi
              
              # Execution
              if ! OUTPUT=$(sfw diff $SANDBOX_OPT "$OLD_FILE" "$NEW_FILE"); then
                  echo "::error::sfw failed on $NEW_FILE_REF"
                  ERROR_COUNT=$((ERROR_COUNT + 1))
                  continue
              fi
              
              # Validation
              if ! echo "$OUTPUT" | jq -e . >/dev/null 2>&1; then
                  echo "::error::Invalid JSON output for $NEW_FILE_REF"
                  ERROR_COUNT=$((ERROR_COUNT + 1))
                  continue
              fi

              PCT=$(echo "$OUTPUT" | jq -r '.summary.semantic_match_pct // 0')
              MODIFIED=$(echo "$OUTPUT" | jq -r '.summary.modified // 0')
              
              if (( $(echo "$PCT < 100" | bc -l) )); then
                  STATUS_ICON=" Modified ($MODIFIED)"
                  
                  if [ "$MODE" == "BLOCKER" ]; then
                      echo "true" > /tmp/failed_refactor
                      echo "::error file=$NEW_FILE_REF::Logic change detected in safe refactor! ($PCT%)"
                  fi
              else
                  STATUS_ICON=" Preserved"
              fi
              
              echo "| \`$NEW_FILE_REF\` | $STATUS_ICON | **$PCT%** |" >> $GITHUB_STEP_SUMMARY

            done < <(git diff -z --name-status "$BASE_REF" "$HEAD_REF")
            
          else
              echo "No Go files changed." >> $GITHUB_STEP_SUMMARY
          fi

          if [ $ERROR_COUNT -gt 0 ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo " **CI FAILED**: Tool execution failures detected." >> $GITHUB_STEP_SUMMARY
              exit 1
          fi

          if [ -f /tmp/failed_refactor ] && [ "$(cat /tmp/failed_refactor)" = "true" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo " **CI FAILED**: Logic changed in 'semantic-safe' PR." >> $GITHUB_STEP_SUMMARY
              exit 1
          fi
          exit 0