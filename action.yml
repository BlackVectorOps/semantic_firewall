name: 'Semantic Firewall'
description: 'Behavioral analysis engine for Go. Detects malware, proves loop equivalence, and enforces semantic immutability.'
author: 'BlackVectorOps'

branding:
  icon: 'shield'
  color: 'purple'

inputs:
  path:
    description: 'Path to file or directory to analyze'
    required: false
    default: '.'
  mode:
    description: 'Operation mode: check, diff, scan, or audit'
    required: false
    default: 'check'
  go-version:
    description: 'Go version to use'
    required: false
    default: '1.24'
  signatures:
    description: 'Path to signature database (scan mode only)'
    required: false
    default: './signatures.db'
  threshold:
    description: 'Match confidence threshold 0.0-1.0 (scan mode only)'
    required: false
    default: '0.75'
  strict:
    description: 'Enable strict mode validation (check mode only)'
    required: false
    default: 'false'
  fail-on-alert:
    description: 'Fail workflow if malware detected (scan mode only)'
    required: false
    default: 'true'
  scan-deps:
    description: 'Scan imported dependencies (scan mode only)'
    required: false
    default: 'false'
  deps-depth:
    description: 'Dependency scan depth: direct or transitive (scan mode only)'
    required: false
    default: 'direct'
  api-key:
    description: 'LLM API Key (audit mode only). Required for intent verification.'
    required: false
  model:
    description: 'LLM Model to use (audit mode only).'
    required: false
    default: 'gpt-4'
  api-base:
    description: 'Custom LLM API Base URL (audit mode only).'
    required: false

outputs:
  result:
    description: 'JSON output from the selected mode'
    value: ${{ steps.run-sfw.outputs.result }}
  alert-count:
    description: 'Number of malware alerts (scan mode)'
    value: ${{ steps.run-sfw.outputs.alert-count }}
  deps-scanned:
    description: 'Number of dependency functions scanned (scan mode with --deps)'
    value: ${{ steps.run-sfw.outputs.deps-scanned }}
  semantic-match-pct:
    description: 'Semantic match percentage (diff mode)'
    value: ${{ steps.run-sfw.outputs.semantic-match-pct }}
  audit-verdict:
    description: 'Final audit verdict (audit mode): PASS or FAIL'
    value: ${{ steps.run-sfw.outputs.audit-verdict }}

runs:
  using: 'composite'
  steps:
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ inputs.go-version }}

    - name: Install sfw
      shell: bash
      run: |
        echo "::notice::Installing sfw from remote registry..."
        # Pinned version preventing supply chain attacks (@latest removed)
        # Removed "Dogfooding" implicit build logic (RCE Vector)
        go install github.com/BlackVectorOps/semantic_firewall/v3/cmd/sfw@v2.2.1

    - name: Run Semantic Firewall
      id: run-sfw
      shell: bash
      env:
        INPUT_MODE: ${{ inputs.mode }}
        INPUT_PATH: ${{ inputs.path }}
        INPUT_STRICT: ${{ inputs.strict }}
        INPUT_SIGNATURES: ${{ inputs.signatures }}
        INPUT_THRESHOLD: ${{ inputs.threshold }}
        INPUT_SCAN_DEPS: ${{ inputs.scan-deps }}
        INPUT_DEPS_DEPTH: ${{ inputs.deps-depth }}
        INPUT_FAIL_ON_ALERT: ${{ inputs.fail-on-alert }}
        # SECURITY FIX: Passed via environment variable, not CLI argument
        SFW_API_KEY: ${{ inputs.api-key }}
        INPUT_MODEL: ${{ inputs.model }}
        INPUT_API_BASE: ${{ inputs.api-base }}
        GITHUB_BASE_REF: ${{ github.base_ref }}
        # Map safe context variables
        PR_TITLE: ${{ github.event.pull_request.title }}
        PR_BODY: ${{ github.event.pull_request.body }}
      run: |
        set -e

        # Ensure path is formatted correctly
        if [[ "$INPUT_PATH" == -* ]]; then
          INPUT_PATH="./$INPUT_PATH"
        fi

        # Check for runsc (gVisor). If missing, soft-fail to --no-sandbox mode
        # to prevent lookPathFunc hard failures in standard CI environments.
        SANDBOX_OPT=""
        if ! command -v runsc &> /dev/null; then
          echo "::warning::runsc (gVisor) not found. Falling back to --no-sandbox mode."
          SANDBOX_OPT="--no-sandbox"
        fi

        echo "::group::Semantic Firewall ($INPUT_MODE mode)"

        EXIT_CODE=0

        case "$INPUT_MODE" in
          check)
            STRICT_FLAG=""
            if [[ "$INPUT_STRICT" == "true" ]]; then
              STRICT_FLAG="--strict"
            fi
            OUTPUT=$(sfw check $STRICT_FLAG $SANDBOX_OPT -- "$INPUT_PATH")
            echo "$OUTPUT"
            ;;

          diff)
            # determine the correct base SHA for comparison
            if [[ -n "$GITHUB_BASE_REF" ]]; then
              # Pull Request
              BASE_SHA=$(git rev-parse origin/$GITHUB_BASE_REF)
            elif [[ "${{ github.event_name }}" == "push" ]]; then
              # Push event -- use the 'before' SHA from the event payload
              BASE_SHA="${{ github.event.before }}"
              # Handle new branch creation where 'before' is all zeros
              if [[ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
                 BASE_SHA="HEAD^"
              fi
            else
              # Fallback
              BASE_SHA=$(git rev-parse HEAD~1)
            fi

            # Setup temp directory for reliable AST parsing of old files
            TEMP_DIR=".sfw_diff_temp_$$"
            mkdir -p "$TEMP_DIR"
            # Attempt to copy go.mod/sum to temp root to preserve module info
            cp go.mod go.sum "$TEMP_DIR/" 2>/dev/null || true

            STREAM_FILE="sfw_stream.jsonl"
            rm -f "$STREAM_FILE"

            # Find changed Go files
            git diff -z --name-only "$BASE_SHA" HEAD -- '*.go' 2>/dev/null > "files_list.tmp" || find "$INPUT_PATH" -name '*.go' -not -name '*_test.go' -print0 > "files_list.tmp"

            TOTAL_MATCH_PCT=0
            FILE_COUNT=0

            while IFS= read -r -d '' file; do
              # skip tests
              if [[ "$file" == *_test.go ]]; then continue; fi

              # Determine New File Path
              if [[ -f "$file" ]]; then
                NEW_FILE="$file"
              else
                NEW_FILE="/dev/null"
              fi

              # Determine Old File Path
              # we reconstruct the directory path in the temp folder
              DIR_PATH=$(dirname "$file")
              mkdir -p "$TEMP_DIR/$DIR_PATH"
              TEMP_OLD="$TEMP_DIR/$file"

              if git show "$BASE_SHA:$file" > "$TEMP_OLD" 2>/dev/null; then
                 OLD_FILE="$TEMP_OLD"
              else
                 # If file didn't exist in base, treat as empty
                 OLD_FILE="/dev/null"
              fi

              # skip if both are effectively gone
              if [[ "$NEW_FILE" == "/dev/null" ]] && [[ "$OLD_FILE" == "/dev/null" ]]; then continue; fi

              # Run Diff
              # captures only stdout to avoid JSON corruption from logs
              DIFF_OUT=$(sfw diff $SANDBOX_OPT "$OLD_FILE" "$NEW_FILE" 2>/dev/null || echo '{}')

              # append to stream file
              echo "$DIFF_OUT" >> "$STREAM_FILE"
              echo "$DIFF_OUT"

              PCT=$(echo "$DIFF_OUT" | jq -r '.summary.semantic_match_pct // 0')
              TOTAL_MATCH_PCT=$(echo "$TOTAL_MATCH_PCT + $PCT" | bc)
              FILE_COUNT=$((FILE_COUNT + 1))

            done < "files_list.tmp"

            # Use jq to slurp the stream into a valid JSON array
            if [[ -f "$STREAM_FILE" ]]; then
              jq -s '.' "$STREAM_FILE" > sfw_diff_results.json
            else
              echo "[]" > sfw_diff_results.json
            fi

            OUTPUT=$(cat sfw_diff_results.json)
            rm -f sfw_diff_results.json "$STREAM_FILE" "files_list.tmp"
            rm -rf "$TEMP_DIR"

            if [[ $FILE_COUNT -gt 0 ]]; then
              AVG_PCT=$(echo "scale=1; $TOTAL_MATCH_PCT / $FILE_COUNT" | bc)
            else
              AVG_PCT="100.0"
            fi
            echo "semantic-match-pct=$AVG_PCT" >> $GITHUB_OUTPUT
            ;;

          audit)
            # Check for Key in Environment (SFW_API_KEY mapped from inputs or globals)
            HAS_KEY="false"
            if [[ -n "$SFW_API_KEY" ]] || [[ -n "$OPENAI_API_KEY" ]] || [[ -n "$GEMINI_API_KEY" ]]; then
              HAS_KEY="true"
            fi

            if [[ "$HAS_KEY" == "false" ]]; then
              echo "::warning::No API Key found. Running in deterministic SIMULATION mode."
            fi

            # Uses PR Context if available, avoids injection by using Env Vars
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
               COMMIT_MSG="$PR_TITLE
            $PR_BODY"
            else
               COMMIT_MSG=$(git log -1 --pretty=%B)
            fi
            echo "::notice::Auditing Context: $COMMIT_MSG"

            if [[ -n "$GITHUB_BASE_REF" ]]; then
              BASE_SHA=$(git rev-parse origin/$GITHUB_BASE_REF)
            else
              BASE_SHA=$(git rev-parse HEAD~1)
            fi

            OLD_FILE=$(mktemp)
            FILES_LIST=$(mktemp)
            AUDIT_FAILS=0

            git diff -z --name-only "$BASE_SHA" HEAD -- '*.go' 2>/dev/null > "$FILES_LIST"

            while IFS= read -r -d '' file; do
              if [[ -f "$file" ]]; then NEW_FILE="$file"; else NEW_FILE="/dev/null"; fi
              if [[ ! -f "$file" ]] && [[ ! -e "$NEW_FILE" ]]; then continue; fi
              if [[ "$file" == *_test.go ]]; then continue; fi
              if [[ "$file" != *.go ]]; then continue; fi

              echo "Analyzing: $file"
              git show "$BASE_SHA:$file" > "$OLD_FILE" 2>/dev/null || echo "" > "$OLD_FILE"

              # Construct arguments for audit
              # API Key is passed implicitly via Environment (SFW_API_KEY)
              AUDIT_ARGS=("$OLD_FILE" "$NEW_FILE" "$COMMIT_MSG")

              AUDIT_ARGS+=("--model" "$INPUT_MODEL")
              if [[ -n "$INPUT_API_BASE" ]]; then
                 AUDIT_ARGS+=("--api-base" "$INPUT_API_BASE")
              fi
              
              if [[ -n "$SANDBOX_OPT" ]]; then
                 AUDIT_ARGS+=("$SANDBOX_OPT")
              fi

              # sfw audit returns 0 on MATCH/SUSPICIOUS, 1 on LIE/ERROR
              set +e
              AUDIT_OUT=$(sfw audit "${AUDIT_ARGS[@]}")
              CMD_EXIT=$?
              set -e

              echo "$AUDIT_OUT"

              # AUDIT FIX: Logic Fail-Open Mitigation
              # If sfw audit returns 0 (Pass) but output implies an internal error (e.g., json unmarshal failure),
              # we must treat it as a failure (Fail-Closed).
              if [[ $CMD_EXIT -eq 0 ]]; then
                 # Check for common Go JSON errors or empty output which might indicate crash
                 if [[ -z "$AUDIT_OUT" ]] || echo "$AUDIT_OUT" | grep -qE "json: error|unexpected end of JSON|invalid character"; then
                    echo "::error file=$file::Internal Audit Error Detected (Unmarshaling or Crash). Failing closed."
                    CMD_EXIT=1
                 fi
              fi

              if [[ $CMD_EXIT -ne 0 ]]; then
                 echo "::error file=$file::Deception Detected! Verdict: LIE"
                 AUDIT_FAILS=$((AUDIT_FAILS + 1))
                 EXIT_CODE=1
              fi

              echo "" > "$OLD_FILE"
            done < "$FILES_LIST"

            rm -f "$OLD_FILE" "$FILES_LIST"

            if [[ $AUDIT_FAILS -eq 0 ]]; then
               echo "audit-verdict=PASS" >> $GITHUB_OUTPUT
               OUTPUT="Audit Passed. No deceptive commits detected."
            else
               echo "audit-verdict=FAIL" >> $GITHUB_OUTPUT
               OUTPUT="Audit Failed. $AUDIT_FAILS file(s) flagged as deceptive."
            fi
            ;;

          scan)
            DEPS_ARGS=()
            if [[ "$INPUT_SCAN_DEPS" == "true" ]]; then
              DEPS_ARGS+=("--deps")
              DEPS_ARGS+=("--deps-depth" "$INPUT_DEPS_DEPTH")
            fi

            #  Check -e instead of -f to support PebbleDB directories
            if [[ ! -e "$INPUT_SIGNATURES" ]]; then
              # SECURITY FIX: Fail closed if database is missing
              echo "::error::Signature database not found at $INPUT_SIGNATURES"
              exit 1
            else
              # : PebbleDB Locking and Concurrency
              # Copy the signature database to a temporary location to ensure
              # unique access if multiple jobs/processes run in parallel.
              TEMP_DB="sfw_sigs_copy_$$"
              cp -R "$INPUT_SIGNATURES" "$TEMP_DB"

              # Applied SANDBOX_OPT and used TEMP_DB
              OUTPUT=$(sfw scan $SANDBOX_OPT --db "$TEMP_DB" --threshold "$INPUT_THRESHOLD" "${DEPS_ARGS[@]}" -- "$INPUT_PATH")
              echo "$OUTPUT"

              # Cleanup temporary DB copy
              rm -rf "$TEMP_DB"

              # jq -r checks for null to prevent pipe failures
              ALERT_COUNT=$(echo "$OUTPUT" | jq -r '.summary.total_alerts // 0')
              echo "alert-count=$ALERT_COUNT" >> $GITHUB_OUTPUT

              DEPS_SCANNED=$(echo "$OUTPUT" | jq -r '.dependencies_scanned // 0')
              echo "deps-scanned=$DEPS_SCANNED" >> $GITHUB_OUTPUT

              if [[ "$INPUT_FAIL_ON_ALERT" == "true" ]] && [[ "$ALERT_COUNT" -gt 0 ]]; then
                echo "::error::Malware detected! $ALERT_COUNT alert(s) found."
                EXIT_CODE=1
              fi
            fi
            ;;

          *)
            echo "::error::Unknown mode: $INPUT_MODE. Use 'check', 'diff', 'scan', or 'audit'."
            EXIT_CODE=1
            ;;
        esac

        echo "::endgroup::"

        # Uses random delimiter to prevent GITHUB_OUTPUT Injection
        DELIMITER=$(openssl rand -hex 8)
        echo "result<<$DELIMITER" >> $GITHUB_OUTPUT
        echo "$OUTPUT" >> $GITHUB_OUTPUT
        echo "$DELIMITER" >> $GITHUB_OUTPUT

        exit $EXIT_CODE