name: 'Semantic Firewall'
description: 'Behavioral analysis engine for Go. Detects malware, proves loop equivalence, and enforces semantic immutability.'
author: 'BlackVectorOps'

branding:
  icon: 'shield'
  color: 'purple'

inputs:
  path:
    description: 'Path to file or directory to analyze'
    required: false
    default: '.'
  mode:
    description: 'Operation mode: check, diff, scan, or audit'
    required: false
    default: 'check'
  go-version:
    description: 'Go version to use'
    required: false
    default: '1.24'
  signatures:
    description: 'Path to signature database (scan mode only)'
    required: false
    default: './signatures.db'
  threshold:
    description: 'Match confidence threshold 0.0-1.0 (scan mode only)'
    required: false
    default: '0.75'
  strict:
    description: 'Enable strict mode validation (check mode only)'
    required: false
    default: 'false'
  fail-on-alert:
    description: 'Fail workflow if malware detected (scan mode only)'
    required: false
    default: 'true'
  scan-deps:
    description: 'Scan imported dependencies (scan mode only)'
    required: false
    default: 'false'
  deps-depth:
    description: 'Dependency scan depth: direct or transitive (scan mode only)'
    required: false
    default: 'direct'
  api-key:
    description: 'LLM API Key (audit mode only). Required for intent verification.'
    required: false
  model:
    description: 'LLM Model to use (audit mode only).'
    required: false
    default: 'gpt-4'
  api-base:
    description: 'Custom LLM API Base URL (audit mode only).'
    required: false

outputs:
  result:
    description: 'JSON output from the selected mode'
    value: ${{ steps.run-sfw.outputs.result }}
  alert-count:
    description: 'Number of malware alerts (scan mode)'
    value: ${{ steps.run-sfw.outputs.alert-count }}
  deps-scanned:
    description: 'Number of dependency functions scanned (scan mode with --deps)'
    value: ${{ steps.run-sfw.outputs.deps-scanned }}
  semantic-match-pct:
    description: 'Semantic match percentage (diff mode)'
    value: ${{ steps.run-sfw.outputs.semantic-match-pct }}
  audit-verdict:
    description: 'Final audit verdict (audit mode): PASS or FAIL'
    value: ${{ steps.run-sfw.outputs.audit-verdict }}

runs:
  using: 'composite'
  steps:
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ inputs.go-version }}

    - name: Install sfw
      shell: bash
      run: |
        echo "::notice::Installing sfw from remote registry..."
        go install github.com/BlackVectorOps/semantic_firewall/v3/cmd/sfw@v3.1.2

    - name: Run Semantic Firewall
      id: run-sfw
      shell: bash
      env:
        INPUT_MODE: ${{ inputs.mode }}
        INPUT_PATH: ${{ inputs.path }}
        INPUT_STRICT: ${{ inputs.strict }}
        INPUT_SIGNATURES: ${{ inputs.signatures }}
        INPUT_THRESHOLD: ${{ inputs.threshold }}
        INPUT_SCAN_DEPS: ${{ inputs.scan-deps }}
        INPUT_DEPS_DEPTH: ${{ inputs.deps-depth }}
        INPUT_FAIL_ON_ALERT: ${{ inputs.fail-on-alert }}
        # SECURITY FIX: Passed via environment variable
        SFW_API_KEY: ${{ inputs.api-key }}
        INPUT_MODEL: ${{ inputs.model }}
        INPUT_API_BASE: ${{ inputs.api-base }}
        GITHUB_BASE_REF: ${{ github.base_ref }}
        PR_TITLE: ${{ github.event.pull_request.title }}
        PR_BODY: ${{ github.event.pull_request.body }}
      run: |
        set -e

        # Input Sanitization: Robust Path Validation
        TARGET_ABS=$(realpath -m "$INPUT_PATH")
        BASE_ABS=$(realpath -m ".")
        REL_PATH=$(realpath -m --relative-to="$BASE_ABS" "$TARGET_ABS")
        
        if [[ "$REL_PATH" == ".."* ]] || [[ "$REL_PATH" == /* ]]; then
           echo "::error::Security Violation: Path Traversal Detected! Target '$INPUT_PATH' is outside the workspace."
           exit 1
        fi
        
        TARGET_PATH="./$REL_PATH"

        # FIX: Fail-Closed Check for runsc
        SANDBOX_OPT=""
        if ! command -v runsc &> /dev/null; then
          echo "::error::Security Requirement Failed: runsc (gVisor) is not installed."
          exit 1
        fi

        echo "::group::Semantic Firewall ($INPUT_MODE mode)"

        EXIT_CODE=0

        # FIX: Local temp dir to prevent /tmp shadowing in sandbox
        LOCAL_TEMP=".sfw_temp_$$"
        mkdir -p "$LOCAL_TEMP"
        trap 'rm -rf "$LOCAL_TEMP"' EXIT

        case "$INPUT_MODE" in
          check)
            STRICT_FLAG=""
            if [[ "$INPUT_STRICT" == "true" ]]; then
              STRICT_FLAG="--strict"
            fi
            OUTPUT=$(sfw check $STRICT_FLAG $SANDBOX_OPT -- "$TARGET_PATH")
            echo "$OUTPUT"
            ;;

          diff)
            if [[ -n "$GITHUB_BASE_REF" ]]; then
              BASE_SHA=$(git rev-parse origin/$GITHUB_BASE_REF)
            elif [[ "${{ github.event_name }}" == "push" ]]; then
              BASE_SHA="${{ github.event.before }}"
              if [[ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
                 BASE_SHA="HEAD^"
              fi
            else
              BASE_SHA=$(git rev-parse HEAD~1)
            fi

            echo "::notice::Diffing against Base SHA: $BASE_SHA"

            WORKTREE_DIR=".sfw_worktree_$$"
            trap 'git worktree remove --force "$WORKTREE_DIR" 2>/dev/null || rm -rf "$WORKTREE_DIR"; rm -rf "$LOCAL_TEMP"' EXIT

            git worktree add --detach "$WORKTREE_DIR" "$BASE_SHA" >/dev/null

            STREAM_FILE="$LOCAL_TEMP/sfw_stream.jsonl"
            
            TOTAL_MATCH_PCT=0
            FILE_COUNT=0

            while IFS= read -r -d '' status; do
              case "$status" in
                R*)
                   IFS= read -r -d '' old_rel_path
                   IFS= read -r -d '' new_rel_path
                   ;;
                *)
                   IFS= read -r -d '' path
                   old_rel_path="$path"
                   new_rel_path="$path"
                   ;;
              esac

              if [[ "$new_rel_path" != *.go ]]; then continue; fi
              if [[ "$new_rel_path" == *_test.go ]]; then continue; fi

              NEW_FILE="$new_rel_path"
              OLD_FILE="$WORKTREE_DIR/$old_rel_path"

              if [[ ! -f "$NEW_FILE" ]]; then NEW_FILE="/dev/null"; fi
              if [[ ! -f "$OLD_FILE" ]]; then OLD_FILE="/dev/null"; fi
              if [[ "$NEW_FILE" == "/dev/null" ]] && [[ "$OLD_FILE" == "/dev/null" ]]; then continue; fi

              echo "Analyzing: $new_rel_path"
              DIFF_OUT=$(sfw diff $SANDBOX_OPT "$OLD_FILE" "$NEW_FILE" 2>/dev/null || echo '{}')

              echo "$DIFF_OUT" >> "$STREAM_FILE"
              
              PCT=$(echo "$DIFF_OUT" | jq -r '.summary.semantic_match_pct // 0')
              TOTAL_MATCH_PCT=$(echo "$TOTAL_MATCH_PCT + $PCT" | bc)
              FILE_COUNT=$((FILE_COUNT + 1))

            done < <(git diff -z --name-status "$BASE_SHA" HEAD)

            if [[ -f "$STREAM_FILE" ]]; then
              jq -s '.' "$STREAM_FILE" > sfw_diff_results.json
            else
              echo "[]" > sfw_diff_results.json
            fi

            OUTPUT=$(cat sfw_diff_results.json)
            rm -f sfw_diff_results.json

            if [[ $FILE_COUNT -gt 0 ]]; then
              AVG_PCT=$(echo "scale=1; $TOTAL_MATCH_PCT / $FILE_COUNT" | bc)
            else
              AVG_PCT="100.0"
            fi
            echo "semantic-match-pct=$AVG_PCT" >> $GITHUB_OUTPUT
            ;;

          audit)
            HAS_KEY="false"
            if [[ -n "$SFW_API_KEY" ]] || [[ -n "$OPENAI_API_KEY" ]] || [[ -n "$GEMINI_API_KEY" ]]; then
              HAS_KEY="true"
            fi

            if [[ "$HAS_KEY" == "false" ]]; then
              echo "::warning::No API Key found. Running in deterministic SIMULATION mode."
            fi

            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
               COMMIT_MSG="$PR_TITLE
            $PR_BODY"
            else
               COMMIT_MSG=$(git log -1 --pretty=%B)
            fi

            if [[ -n "$GITHUB_BASE_REF" ]]; then
              BASE_SHA=$(git rev-parse origin/$GITHUB_BASE_REF)
            else
              BASE_SHA=$(git rev-parse HEAD~1)
            fi

            WORKTREE_DIR=".sfw_audit_worktree_$$"
            trap 'git worktree remove --force "$WORKTREE_DIR" 2>/dev/null || rm -rf "$WORKTREE_DIR"; rm -rf "$LOCAL_TEMP"' EXIT
            git worktree add --detach "$WORKTREE_DIR" "$BASE_SHA" >/dev/null

            FILES_LIST="$LOCAL_TEMP/files_list.txt"
            AUDIT_FAILS=0

            git diff -z --name-only "$BASE_SHA" HEAD -- '*.go' 2>/dev/null > "$FILES_LIST"

            while IFS= read -r -d '' file; do
              if [[ ! -f "$file" ]]; then continue; fi
              if [[ "$file" == *_test.go ]]; then continue; fi

              echo "Auditing: $file"
              
              NEW_FILE="$file"
              OLD_FILE="$WORKTREE_DIR/$file"
              
              # Handle new files (Old file won't exist in worktree)
              if [[ ! -f "$OLD_FILE" ]]; then
                 # FIX: Create temp file in LOCAL_TEMP (inside workspace)
                 # This prevents the sandbox from masking the file via /tmp overlay
                 OLD_FILE=$(mktemp -p "$LOCAL_TEMP")
              fi

              AUDIT_ARGS=("$OLD_FILE" "$NEW_FILE" "$COMMIT_MSG")
              AUDIT_ARGS+=("--model" "$INPUT_MODEL")
              if [[ -n "$INPUT_API_BASE" ]]; then
                 AUDIT_ARGS+=("--api-base" "$INPUT_API_BASE")
              fi
              if [[ -n "$SANDBOX_OPT" ]]; then
                 AUDIT_ARGS+=("$SANDBOX_OPT")
              fi

              set +e
              AUDIT_OUT=$(sfw audit "${AUDIT_ARGS[@]}")
              CMD_EXIT=$?
              set -e

              echo "$AUDIT_OUT"

              if [[ $CMD_EXIT -eq 0 ]]; then
                 if [[ -z "$AUDIT_OUT" ]] || echo "$AUDIT_OUT" | grep -qE "json: error|unexpected end of JSON|invalid character"; then
                    echo "::error file=$file::Internal Audit Error. Failing closed."
                    CMD_EXIT=1
                 fi
              fi

              if [[ $CMD_EXIT -ne 0 ]]; then
                 echo "::error file=$file::Deception Detected! Verdict: LIE"
                 AUDIT_FAILS=$((AUDIT_FAILS + 1))
                 EXIT_CODE=1
              fi

            done < "$FILES_LIST"

            if [[ $AUDIT_FAILS -eq 0 ]]; then
               echo "audit-verdict=PASS" >> $GITHUB_OUTPUT
               OUTPUT="Audit Passed."
            else
               echo "audit-verdict=FAIL" >> $GITHUB_OUTPUT
               OUTPUT="Audit Failed."
            fi
            ;;

          scan)
            DEPS_ARGS=()
            if [[ "$INPUT_SCAN_DEPS" == "true" ]]; then
              DEPS_ARGS+=("--deps")
              DEPS_ARGS+=("--deps-depth" "$INPUT_DEPS_DEPTH")
            fi

            if [[ ! -e "$INPUT_SIGNATURES" ]]; then
              echo "::error::Signature database not found at $INPUT_SIGNATURES"
              exit 1
            else
              TEMP_DB="$LOCAL_TEMP/sfw_sigs_copy.db"
              cp -R "$INPUT_SIGNATURES" "$TEMP_DB"

              OUTPUT=$(sfw scan $SANDBOX_OPT --db "$TEMP_DB" --threshold "$INPUT_THRESHOLD" "${DEPS_ARGS[@]}" -- "$TARGET_PATH")
              echo "$OUTPUT"

              ALERT_COUNT=$(echo "$OUTPUT" | jq -r '.summary.total_alerts // 0')
              echo "alert-count=$ALERT_COUNT" >> $GITHUB_OUTPUT

              DEPS_SCANNED=$(echo "$OUTPUT" | jq -r '.dependencies_scanned // 0')
              echo "deps-scanned=$DEPS_SCANNED" >> $GITHUB_OUTPUT

              if [[ "$INPUT_FAIL_ON_ALERT" == "true" ]] && [[ "$ALERT_COUNT" -gt 0 ]]; then
                echo "::error::Malware detected! $ALERT_COUNT alert(s) found."
                EXIT_CODE=1
              fi
            fi
            ;;

          *)
            echo "::error::Unknown mode: $INPUT_MODE."
            EXIT_CODE=1
            ;;
        esac

        echo "::endgroup::"

        DELIMITER=$(openssl rand -hex 8)
        echo "result<<$DELIMITER" >> $GITHUB_OUTPUT
        echo "$OUTPUT" >> $GITHUB_OUTPUT
        echo "$DELIMITER" >> $GITHUB_OUTPUT

        exit $EXIT_CODE